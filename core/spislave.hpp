/**
 * \file spislave.hpp
 *
 * @date 2018/02/14
 * @author Seiichi "Suikan" Horie
 * @brief SPI Slave. Thread safe and synchronous IO
 */

#ifndef SPISLAVE_HPP_
#define SPISLAVE_HPP_

#include <spislavestrategy.hpp>
#include <synchronizer.hpp>
#include "criticalsection.hpp"

// Check if CubeIDE genrated SPI module
#ifdef HAL_SPI_MODULE_ENABLED

namespace murasaki {
/**
 * @brief Thread safe, synchronous and blocking IO. Encapsulating SPI slave. Based on STM32Cube HAL driver and FreeRTOS
 * \details
 * The SpiSlave class is the wrapper of the SPI controller.
 *
 * ### Configuration
 * To configure the SPI peripheral as slave, chose SPI peripheral in the Device Configuration Tool
 * of the CubeIDE. Set it as SPI Duplex Slave
 *
 * @image html "spislave-config-1.png"
 * @image latex "spislave-config-1.png" width=4.61in
 *
 * SpiMaster class supports the Duplex slave, 8bit mode only.
 * Also the clock phase and Clock polarity have to be configured by the configuration tool.
 * This is different from master.
 *
 * The DMA have to be enabled for both TX and RX. The data size is 8bit for both Peripheral and memory.
 *
 * @image html "spislave-config-2.png"
 * @image latex "spislave-config-2.png" width=3.08in
 *
 * And then, enable the interrupt.
 * @image html "spislave-config-3.png"
 * @image latex "spislave-config-3.png" width=3.09in
 *
 *
 *
 * ### Creating a peripheral object
 * To use the SpiSlave class,
 * make an instance with SPI_HandleTypeDef * type pointer. For example, to create
 * an instance for the SPI3 peripheral :
 * \code
 *     my_spi3 = new murasaki::SpiSlave(&hspi3);
 * \endcode
 * Where hspi3 is the handle generated by CubeIDE for SPI3 peripheral.
 *
 * ### Handling an interrupt
 *
 * Interrupt is handled automatically. Programmer doesn't need to care.
 *
 * ### Transmitting and Receiving
 * Once the instance and callback are correctly prepared, we can use the Transfer member function.
 *
 * The @ref SpiSlave::TransmitAndReceive() member function is a synchronous function. A programmer can specify the
 * timeout by timeout_ms parameter. By default, this parameter is set by kwmsIndefinitely
 * which specifies never time out.
 *
 *
 * This member function can be called from only the task context. If these are called in the ISR
 * context, the result is unknown.
 *
 *
 * Other error will cause the re-initializing of the SPI slave. Murasaki doesn't support
 * any of CRC detection, TI frame mode or Multi-master SPI.
 * @ingroup MURASAKI_GROUP
 */
class SpiSlave : public SpiSlaveStrategy
{
 public:
    /**
     * @brief Constractor
     * @param spi_handle Handle to the SPI peripheral. This have to be configured to use DMA by CubeIDE.
     */
    SpiSlave(
             SPI_HandleTypeDef *spi_handle);
    virtual ~SpiSlave();
    /**
     * @brief Data transfer to/from SPI slave.
     * @param tx_data Data to be transmitted
     * @param rx_data Data buffer to receive data
     * @param size Transfer data size [byte] for each way.
     * @param transfered_count ( Currently, Just ignored) The transfered number of bytes during API.
     * @param timeout_ms Timeout limit [mS]
     * @return true if transfer complete, false if timeout
     * @details
     * Transfer the data to/from SPI slave specified by parameter spi_spec.
     *
     * This member funciton re-initialize the SPI peripheral based on the clock information
     * from the spi_spec. And then, assert the chips elect through the spi_spec during the
     * data transfer.
     *
     * Following are the return codes:
     * @li @ref murasaki::kspisOK : The transfer complete without error.
     * @li @ref murasaki::kspisModeCRC : CRC error was detected.
     * @li @ref murasaki::kspisOverflow : SPI overflow or underflow was detected.
     * @li @ref murasaki::kspisFrameError Frame error in TI mode.
     * @li @ref murasaki::kspisDMA : Some DMA error was detected in HAL. SPI re-initialized.
     * @li @ref murasaki::kspisErrorFlag : Unhandled flags. SPI re-initialized.
     * @li @ref murasaki::ki2csTimeOut : Timeout detected. DMA stopped.
     * @li Other : Unhandled error . SPI re-initialized.
     */
    virtual SpiStatus TransmitAndReceive(
                                         const uint8_t *tx_data,
                                         uint8_t *rx_data,
                                         unsigned int size,
                                         unsigned int *transfered_count,
                                         unsigned int timeout_ms = murasaki::kwmsIndefinitely);
    /**
     * @brief Callback to notify the end of transfer
     * @param ptr Pointer to the control object.
     * @return true if no error.
     *
     * This member function have to be called from HAL_SPI_TxRxCpltCallback()
     *
     * \code
     * void HAL_SPI_TxRxCpltCallback (SPI_HandleTypeDef * hspi)
     * {
     *      if ( murasaki::platform.spi1->TransmitAndReceiveCompleteCallback(hspi))
     *          return;
     * }
     * \endcode
     */
    virtual bool TransmitAndReceiveCompleteCallback(void *ptr);
    /**
     * @brief Error handling
     * @param ptr Pointer to I2C_HandleTypeDef struct.
     * \return true: ptr matches with device and handle the error. false : doesn't match.
     * @details
     * A handle to print out the error message.
     *
     * Checks whether handle has error and if there is, print appropriate error. Then return.
     *
     * This member function have to be called from HAL_SPI_ErrorCallback()
     *
     * @code
     * void HAL_SPI_ErrorCallback(SPI_HandleTypeDef * hspi) {
     *      if ( murasaki::platform.spi1->HandleError(hspi) )
     *          return;
     * }
     * @endcode
     */
    virtual bool HandleError(void *ptr);
     private:
    /**
     * @brief Return the Platform dependent device control handle.
     * @return Handle of device.
     * @details
     * The handle is the pointer ( or some ID ) which specify the control data of
     * specific device.
     */
    virtual void* GetPeripheralHandle();
     protected:
    SPI_HandleTypeDef *const peripheral_;        // SPI peripheral handler.
    Synchronizer *const sync_;          // sync between task and interrupt
    CriticalSection *const critical_section_;    // protect memberfunction
 private:
    SpiStatus interrupt_status_;
};

} /* namespace murasaki */

#endif // HAL_SPI_MODULE_ENABLED

#endif /* SPISLAVE_HPP_ */
