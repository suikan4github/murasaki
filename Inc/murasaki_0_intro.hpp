/**
 * \file murasaki_0_intro.hpp
 *
 * \date 2018/02/01
 * \author Seiichi "Suikan" Horie
 * \brief Doxygen document file. No need to include.
 */

#ifndef MURASAKI_0_INTRO_HPP_
#define MURASAKI_0_INTRO_HPP_

/**
 * \page murasaki_ug_preface Preface
 * \brief Murasaki, is a class library on the STM32Cube HAL and FreeRTOS.
 * \details
 * By using Murasaki, you can program STM32 series quickly and easily. You can obtain the
 * source code of the Murasaki Library from the <a href="https://github.com/suikan4github/murasaki">GitHub repository</a>.
 *
 * Murasaki has following design philosophies:
 *
 * \li \subpage intro_sec1
 * \li \subpage intro_sec2
 * \li \subpage intro_sec3
 * \li \subpage intro_sec4
 * \li \subpage intro_sec5
 * \li \subpage intro_sec6
 * \li \subpage intro_sec7
 * \li \subpage intro_sec8
 *
 * \page intro_sec1 Simplified IO
 * \brief The IO function is packaged by class types. For example, The murasaki::Uart class can
 * receive a UART handle
 *
 * \code
 * murasaki::AbstractUart * uart3 = new murasaki::Uart( &huart3 );
 * \endcode
 *
 * Where huart3 is a UART port 3 handle generated by the CubeMX.
 *
 * The STM32Cube HAL is quite rich and flexible. On the other hand, it is quite huge and complex.
 * The classes in Murasaki simplifies it by letting flexibility beside.
 * For example, the murasaki::Uart class  can support only the DMA transfer.
 * The interrupt-based transfer is not supported.
 * By giving up the flexibility, programming with Murasaki is easier than using HAL directly.
 *
 * \page intro_sec2 Preemptive multi-task
 * \brief The Murasaki class library is buit on FreeRTOS's preemptive configuration.
 * As a result, Murasaki is automatically aware with preemptive multi-task.
 *
 * That means, Murasaki's classes don't use polling to wait for any event. Then, a task
 * can do some job while other tasks are waiting for some event.
 *
 * The multi-task programming helps to divide a bigger program to sub-units. This is
 * a good way to develop a large program easier.
 * And the more important point, it is easier to maintain.
 *
 * \page intro_sec3 synchronous IO
 * \brief The synchronous IO is one of the most important features of Murasaki.
 *
 * The peripheral wrapping class like murasaki::Uart provides a set of member functions
 * to do the data transmission/receiving. Such the member functions are programmed
 * as "synchronous" IO.
 *
 * The synchronous IO function doesn't return until each IO function finished completely.
 * For example, if you transmit 10bytes through the UART, the IO member function
 * transmits the 10bytes data, and then, return.
 *
 * Note: Sometimes, the "completion" means the end of the DMA transfer session, rather than
 * the true transmission of the last byte. In this case, system generates a completion
 * interrupt while the data is still in FIFO of the peripheral. This is a hardware issue.
 *
 * To provide the synchronous IO, some member functions are restricted to use only in
 * the task context.
 *
 * \page intro_sec4 Thread safe IO
 * \brief The synchronous IO and the  preemptive multi-task provide easier programming.
 * On the other hand, there is a possibility that two different task accesses
 * one peripheral simultaneously.
 * This kind of access messes the peripheral's behavior.
 *
 * To prevent this condition, each peripheral wrapping class has exclusive access mechanism
 * by mutex.
 *
 * By this mechanism, if two tasks try to transmit though one peripheral, one task
 * is kept waiting until the other finished to transmit. This is blocking behavior. 
 *
 * \page intro_sec5 Versatile printf() logger
 * \brief Logging or "printf debug" is a strong tool in the embedded system development.
 *
 * Murasaki has three levels of the printf debugging mechanism. One is the \ref murasaki::debugger->Printf(),
 * the second is \ref MURASAKI_ASSERT macro. In addtion to these two, \ref MURASAKI_SYSLOG macro is avairable.
 *
 * The murasaki::debugger->Printf() is flexible output mechanism which has several good
 * features :
 * \li printf() compatible parameters.
 * \li Task/interrupt bi-context operation
 * \li None-blocking logging by internal buffer.
 * \li User configurable output port
 *
 * These features allow a programmer to do the printf() debug not only in the task context
 * but also in the interrupt context.
 *
 * \page intro_sec6 Guard by assertion
 * \brief In addition to the murasaki::debugger->Printf(), programmer can use \ref MURASAKI_ASSERT macro.
 * This allows easy assertion and logging. This macro uses the murasaki::debugger->Printf()
 * internally.
 *
 * This assertion is used inside Murasaki class library.
 * As a result, the wrong context, wrong parameter, etc will be reported to the debugger output.
 *
 * \page intro_sec7 System Logging
 * \brief \ref MURASAKI_SYSLOG provides the message output based on the level and filtering.
 * This mechanism is intended to help the Murasaki library development. But also application
 * can use this mechanism.
 *
 * \page intro_sec8 Configurable
 * \brief Murasaki is configurable from the two point of view.
 *
 * First, Musaraki's modules enable only when the relevant peripheral is generated by CubeMX.
 * This allows you set the CubeMX to generate only the used peripheral's source code.
 * Such the setting makes total source code smaller.
 * In the other hand, all unused drivers are invisible.
 * For example, if you don't enable the I2C pins on CubeMX, Murasaki cannot see such the
 * module.
 *
 * Murasaki can adopt such the situation. The source code of Murasaki relevant to the
 * peripheral which is not generated, will be disabled by ifdef control.
 *
 * The Second part of the configurable characteristics is Murasaki itself.
 * The programmer can customize the Murasaki for example, task stack size.
 *
 */

#endif /* MURASAKI_0_INTRO_HPP_ */
