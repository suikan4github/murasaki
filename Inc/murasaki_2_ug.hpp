/**
 * \file murasaki_2_ug.hpp
 *
 * \date 2018/02/01
 * \author takemasa
 * \brief Doxygen document file. No need to include.
 */

#ifndef MURASAKI_2_UG_HPP_
#define MURASAKI_2_UG_HPP_


/**
 * \page murasaki_ug_usage Usage Introduction
 * \brief In this introduction, we see how to use  Murasaki class library in the STM32 program.
 * \details
 *
 * In this seciton, we see fowling issues :
 * \li \subpage ug_sec_1
 * \li \subpage ug_sec_2
 * \li \subpage ug_sec_3
 * \li \subpage ug_sec_4
 * \li \subpage ug_sec_5
 *
 * For the easy-to-understand description, we assumes several things on the application skeleton which we are going to use Murasaki :
 * \li The application skeleton is generated by <a href= "http://www.st.com/ja/development-tools/stm32cubemx.html"> CubeMX </a>
 * \li The application skeleton is configured to use FreeRTOS
 * \li UART3 is configured to work with DMA.
 *
 *
 *
 * \page ug_sec_1 Message output
 * \brief The Murasaki library has a Printf() like message output mechanism.
 *
 * This mechanism is easy way to display a message from an embedded microcomputer to the
 * terminal simulator like kermit on a host computer. Murasaki's Printf() is based on the
 * standard C language formating library. So, programmer can output a message as like standard printf().
 *
 * As usual, let's start from "hello, world".
 *
 * \code
 * murasaki::debugger->Printf("Hello, world!\n\r");
 * \endcode
 *
 * In Murasaki manner, the Printf() is not a global function. This is a method of murasaki::Debugger class.
 * The murasaki::debugger variable is a one of two Murasaki's golobal variable. And it provide an easy
 * to use message output.
 *
 * The end-of-line charater is depend on the terminal. In the above sample, the terminator is \n\r.
 * This is for the linux based kermit. Other terminal system may need other end-of-line character.
 *
 * Because the Printf() works as like standard printf(), you can also use the format string.
 *
 * \code
 * murasaki::debugger->Printf("count is %d\n\r", count);
 * \endcode
 *
 * The Printf() is designed as debugger message output for an embeded realtime system.
 * Thenk this function is :
 * \li Thread safe
 * \li Blocking
 * \li Buffered
 *
 * In the other word, you can use this function in either task or interrupt handler without bothering
 * the real time process.
 */


/**
 * \page ug_sec_2 Serial communication
 * \brief murasaki::Uart is the asynchronous serial communication.
 *
 * The initial baud rate, parity and data size are defined by CubeMX.
 * So, there is no need to initialize the communication parameter in application program.
 * User can transmit data by just passing its address and size.
 *
 *
 * @code
 *        uint8_t data[5] = { 1, 2, 3, 4, 5 };
 *        murasaki::UartStatus stat;
 *
 *        stat = murasaki::platform.uart->Transmit(
 *                                                 data,
 *                                                 5);
 *
 * @endcode
 *
 * Beside of transmit, also Receive() member function exists.
 *
 */


/**
 * \page ug_sec_3 Debugging with Murasaki.
 * \brief As we saw, Murasaki has simple messaging output for realtime debug.
 *
 * This feature is
 * typically used as UART serial output, but configurable by programmer.
 *
 * The murasaki::debugger is the useful variable to output the debugging message.
 * murasaki::debugger->prrntf() has several good feature.
 * \li Versatile printf() style format string.
 * \li Can call from both task and interrupt context
 * \li Non blocking
 *
 * These features helps programmer to display message in the real-time, multi-task application.
 *
 * In addition to this simple debugging variable, a programmer can use assert_failure() function of the STM32 HA.
 * The STM32Cube HAL has assert_failure() to check the parameter on the fly.
 * By default, this function is disabled.
 * To use this function, programmer have to make it enable, and add function to receive the
 * debug information.
 *
 * To enable the assert_failuer(), edit the stm32fxx_hal_conf.h in the Inc directory. This
 * file is generated by CubeMX. You can find USE_FULL_ASERT macro as comment out.
 * By declaring this macro, assert_failure is enabled.
 *
 * \code
 * #define USE_FULL_ASSERT    1
 * \endcode
 *
 * And then, you should modify assert_failure() in main.c, to call output function.
 *
 * \code
 * void assert_failed(uint8_t* file, uint32_t line)
 * {
 *     CustomAssertFailed(file, line);  // debugging stub.
 * }
 * \endcode
 *
 * Finally, you must define the output function.
 *
 * \code
 * // Hook for the assert_failure() in main.c
 * void CustomAssertFailed(uint8_t* file, uint32_t line)
 * {
 *     murasaki::debugger->Printf("Wrong parameters value: file %s on line %d\r\n", file, line);
 * }
 *
 * \endcode
 * Once above programming is done, you can watch the integrity of the HAL parameter by
 * reading the console output.
 *
 * Above debugging mechanism redirects all HAL assertion , Murasaki assertion and
 * application debug message to the specified logging port.
 * That logging port is able to customize.
 * In the case of the User's Guide, logging is done through the UART port.
 *
 * Time by time, you may not wnat to connect serial terminal to the board, unless you have problem.
 * That means, when you find problem and connect your serial terminal, the assertion
 * message is already transmitted ( and lost ).
 *
 * Murasaki can save this problem.
 * By adding following code after creating murasaki::Debugger instance, you can use history functionality.
 *
 * @code
 *     murasaki::debugger->AutoHistory();
 * @endcode
 *
 * The murasaki::Debugger::AutoHistory() creates a dedicated task for auto history function.
 * This task watch the input from the logging port.
 * Again, in this User's guide it is UART.
 * Once any character is received from the logging port ( terminal ),
 * previously transmitted message are sent again.
 * So you can read the last tens of messages.
 *
 * The auto history is handy, but it blocks all input from the terminal.
 * If you want to have your own console program through the debug port input,
 * do not you the auto history. Alternatively, you can send the previously transmitted message again,
 * by calling murasaki::Debugger::PrintHistory() explicitly.
 *
 */

/**
 * \page ug_sec_4 Tasking
 * @brief murasaki::Task is a type of the task of the FreeRTOS.
 *
 * By using murasaki::Task, a programmer can easily create a task object.
 * This object encapsulate the task of the FreeRTOS.
 *
 * First of all, you must define a task body function.
 * Any function name is acceptable, Only the return type and parameter type is specified.
 *
 *
 * @code
 * // Task body of the murasaki::platform.task1
 * void TaskBodyFunction(const void* ptr)
 *                       {
 *
 *     while (true)    // dummy loop
 *     {
 *         murasaki::platform.led2->Toggle();  // toggling LED
 *         murasaki::Sleep(static_cast<murasaki::WaitMilliSeconds>(700));
 *     }
 * }
 * @endcode
 *
 * Then, create a Task object.
 *
 * There are several parameter to pass for the constructor.
 * The first parameter is the name of the task in FreeRTOS.
 * The second one is the task stack size. This size is depend on the
 * task body function. The third one is the priority of the new task.
 * This bigger value is the higher priority. The fourth one is the pointer
 * to the task parameter. This parameter is passed to the task function body.
 * And then, the last one is the pointer to the task body function.
 *
 * @code
 *     // For demonstration of FreeRTOS task.
 *     murasaki::platform.task1 = new murasaki::Task(
 *                                                   "Master",
 *                                                   256,
 *                                                   (( configMAX_PRIORITIES > 1) ? 1 : 0),
 *                                                   nullptr,
 *                                                   &TaskBodyFunction
 *                                                   );
 * @endcode
 *
 * Once task object is created, you must call Start() member function to start the task.
 *
 * @code
 *    murasaki::platform.task1->Start();
 * @endcode
 *
 * Then, task you can call Start() member function to run.
 */


/**
 * @page ug_sec_5 Other peripheral
 * @brief This section shows samples of the other peripherals.
 * @li @subpage ug_sect_5_1
 * @li @subpage ug_sect_5_2
 * @li @subpage ug_sect_5_3
 * @li @subpage ug_sect_5_4
 * @li @subpage ug_sect_5_5
 */

/**
 * @page ug_sect_5_1 I2C Master
 * @brief \ref murasaki::I2cMaster class provides the serial communication
 *
 * The I2C master is easy to use. To send a message to the slave device, you need to specify the slave address in 7bits, pointer to data and data size in byte.
 * @code
 *        uint8_t data[5] = { 1, 2, 3, 4, 5 };
 *        murasaki::I2cStatus stat;
 *
 *        stat = murasaki::platform.i2cMaster->Transmit(
 *                                                      127,
 *                                                      data,
 *                                                      5);
 * @endcode
 *
 * In addition to the Transmit(), murasaki::I2cMaster class has Receive(), and TransmitThenReceive() member function.
 */

/**
 * @page ug_sect_5_2 I2C Slave
 * @brief \ref murasaki::I2cSlave class provides the I2C slave function.
 *
 * The I2C slave is much easier than master, because it doesn't need to specify the slave address. The I2C slave device address is given by CubeMX.
 * @code
 *        uint8_t data[5];
 *        murasaki::I2cStatus stat;
 *
 *        stat = murasaki::platform.i2cSlave->Receive(
 *                                                    data,
 *                                                    5);
 * @endcode
 * In addition to the Transmit(), murasaki::I2cSlave class has Receive() member function.
 *
 */

/**
 * @page ug_sect_5_3 SPI Master
 * @brief murasaki::SpiMaster is the SPI master class of Murasaki.
 *
 * This class is more complicated than other peripherals, because of flexibility.
 * The SPI master controller must adapt to the several variation of the SPI communication.
 * \li CPOL configuration
 * \li CPHA configuration
 * \li GPIO port configuration to select a slave
 *
 * The flexibility to above configurations need special mechanism. In Murasaki, this flexibility is responsibility of the murasaki::SpiSlaveSpecifier class.
 * This class holds these configuration. Then, passed to the master class.
 *
 * So, you must create a murasaki::SpiSlaveSpecifier class object, at first.
 * @code
 *         // Create a slave specifier. This object specify the protocol and slave select pin
 *         murasaki::AbstractSpiSlaveSpecifier * slave_spec;
 *         slave_spec = new murasaki::SpiSlaveSpecifier(
 *                                                    murasaki::kspoFallThenRise,
 *                                                    murasaki::ksphLatchThenShift,
 *                                                    SPI_SLAVE_SEL_GPIO_Port,
 *                                                    SPI_SLAVE_SEL_Pin
 *                                                    );
 * @endcode
 *
 * Then, you can pass the SpiSlaveSpecifier class object to the murasaki::SpiMaster::TransmitAndRecieve() function.
 * @code
 *         // Transmit and receive data through SPI
 *         uint8_t tx_data[5] = { 1, 2, 3, 4, 5 };
 *         uint8_t rx_data[5];
 *         murasaki::SpiStatus stat;
 *         stat = murasaki::platform.spiMaster->TransmitAndReceive(
 *                                                                 slave_spec,
 *                                                                 tx_data,
 *                                                                 rx_data,
 *                                                                 5);
 * @endcode
 */

/**
 * @page ug_sect_5_4 SPI Slave
 * @brief murasaki::SpiSlave class provides the SPI slave functionality.
 *
 * This class encapsulate the SPI slave function.
 * @code
 *         // Transmit and receive data through SPI
 *         uint8_t tx_data[5] = { 1, 2, 3, 4, 5 };
 *         uint8_t rx_data[5];
 *         murasaki::SpiStatus stat;
 *         stat = murasaki::platform.spiSlave->TransmitAndReceive(
 *                                                                tx_data,
 *                                                                rx_data,
 *                                                                5);
 * @endcode
 */

/**
 * @page ug_sect_5_5 GPIO
 * @brief murasaki::BitOut and murasaki::BitIn provides the GPIO functionality

 * Following is the example of the murasaki::BitOut class.
 * @code
 *         // Toggle LED.
 *         murasaki::platform.led->Toggle();
 * @endcode
 * In addition to the Toggle(), BitIn has Set() and Clear() member function.
 */


#endif /* MURASAKI_2_UG_HPP_ */
