/**
 * @file murasaki_4_mod.hpp
 *
 * @date May 25, 2018
 * @author Seiichi "Suikan" Horie
 * @brief Module definition
 */

#ifndef MURASAKI_4_MOD_HPP_
#define MURASAKI_4_MOD_HPP_

/**
 * \defgroup MURASAKI_GROUP Murasaki Class Collection
 * \brief STM32 Class library.
 * \details
 * This is a reference guide of murasaki class library.
 * This guide describes class by class and cover entire library.
 * It is not recommended to read the reference for the first time user.
 *
 * Alternatively, the \ref murasaki_ug_usage is provided to study step by step.
 */

/**
 * \ingroup MURASAKI_GROUP
 * \defgroup MURASAKI_SYNC_GROUP Synchronization and Exclusive access
 * \brief Sync between the task and interrupt. Make the resources thread safe.
 * \details
 * These classes are used as parts of the other classes.
 */

/**
 * \ingroup MURASAKI_GROUP
 * \defgroup MURASAKI_THIRDPARTY_GROUP Third party classes
 * @brief Classes for the thirdparty devices.
 */

/**
 * \ingroup MURASAKI_GROUP
 * \defgroup MURASAKI_DEFINITION_GROUP Definitions and Configuration
 * \brief Definitions and configuration collection of murasaki platform.
*/


/**
 * \ingroup MURASAKI_GROUP
 * \defgroup MURASAKI_PLATFORM_GROUP Application Specific Platform
 * \brief Variables to control the hardware.
 *
 * Typical usage of these variables can be seen below. First of all, an .cpp file have to include murasaki.hpp.
 * \code
 * #include "murasaki.hpp"
 * \endcode
 * And then, define the murasaki::debugger in the global context. Note that this is essential to use certain
 * debug macros.
 *
 * The definition of the murasaki::platform is optional. But it is
 * recommended to declare for the ease of reading.
 *
 * \code
 * murasaki::Debugger * murasaki::debugger;
 * murasaki::Platform * murasaki::platform;

 * \endcode
 * Finally, initialize the murasaki::debugger and murasaki::platform. Again, the murasaki::debugger is essential to use the
 * debug macro. The debug macros are used inside murasaki class library. Then, it is mandatory to initialize the
 * debugger member variable.
 *
 * The following code fragment initialize only the debugger related member variables. Also,
 * the murasaki::Platform variable is refereed.
 *
 * The platfrom.uart_console member variable hooks a murasaki::AbstractUart class variable. In this sample,
 * The murasaki::Uart class is instantiated. The Uart constructor
 * receives the pointer to the UART_HandleTypeDef. Usually, the UART_HandleTypeDef variable is generated by
 * CubeMX. For example, "huart3" variable in the main.c file.
 *
 * The platform.logger member variable hooks a murasaki::AbstractLogger variable. In this example, murasaki::UartLogger
 * class variable is instantiated.
 *
 * Finally, the debugger variable is initialized. The murasaki::Debugger constructor receives murasaki::AbstractLogger * type.
 * \code
 * void InitPlatform(UART_HandleTypeDef * uart_handle)
 * {
 *     murasaki::platform.uart_console = new murasaki::Uart(uart_handle);
 *     murasaki::platform.logger = new murasaki::UartLogger(murasaki::platform.uart_console);
 *
 *     murasak::debugger = new murasaki::Debugger(murasaki::platform.logger);
 * }
 *
 * \endcode
 */

/**
 * \ingroup MURASAKI_GROUP
 * \defgroup MURASAKI_ABSTRACT_GROUP Abstract Classes
 * \brief Generic classes as template of the concrete class.
 * \details
 * Usually, application dodesn't instanciate these classes. But pointer may be clecalared
 * as abstract class as geneic placeholder.
 */


/**
 * @ingroup MURASAKI_GROUP
 * @defgroup MURASAKI_HELPER_GROUP Helper classes
 * @brief Classes to support the murasaki-class.
 * @details
 * These classess are not used by customer.
 */



#endif /* MURASAKI_4_MOD_HPP_ */

