/**
 * @file murasaki_4_mod.hpp
 *
 * @date May 25, 2018
 * @author Seiichi "Suikan" Horie
 * @brief Module definition
 */

#ifndef MURASAKI_4_MOD_HPP_
#define MURASAKI_4_MOD_HPP_

/**
 * \defgroup MURASAKI_PLACEHOLDER Murasaki API reference
 * \brief Murasaki API reference place holder.
 * \details
 */

/**
 * \defgroup MURASAKI_GROUP Murasaki Class Collection
 * \ingroup MURASAKI_PLACEHOLDER
 * \brief STM32 Class library.
 * \details
 * This page is a reference guide to the murasaki class library.
 * This guide describes class by class and cover the entire library.
 * It is not recommended to read the reference for the first time user.
 *
 * A programmer should read the \ref murasaki_ug_usage as the first step.
 */

/**
 * \defgroup MURASAKI_THIRDPARTY_GROUP Third party classes
 * \ingroup MURASAKI_PLACEHOLDER
 * @brief Classes for the thirdparty devices.
 */

/**
 * \defgroup MURASAKI_DEFINITION_GROUP Definitions and Configuration
 * \ingroup MURASAKI_PLACEHOLDER
 * \brief Definitions and configuration collection of murasaki platform.
 */

/**
 * \defgroup MURASAKI_PLATFORM_GROUP Application Specific Platform
 * \ingroup MURASAKI_PLACEHOLDER
 *  \brief Variables to control the hardware.
 *
 *  The typical usage of these variables can be seen below. First of all, a .cpp file has to include murasaki.hpp.
 *  \code
 *  #include "murasaki.hpp"
 *  \endcode
 *  And then, define the murasaki::debugger in the global context. Note that this is essential to use certain debug macros.
 *
 *  The definition of the murasaki::platform is optional. But it is
 *  recommended declaring for the ease of reading.
 *
 *  \code
 *  murasaki::Debugger * murasaki::debugger;
 *  murasaki::Platform * murasaki::platform;
 *
 *  \endcode
 *  Finally, initialize the murasaki::debugger and murasaki::platform. Again, the murasaki::debugger is essential to use the debug macro. The debug macros are used inside the murasaki class library. Then, it is mandatory to initialize the debugger member variable.
 *
 *  The following code fragment initializes only the debugger related member variables. Also, the murasaki::Platform variable is refereed.
 *
 *  The platfrom.uart_console member variable hooks a murasaki::AbstractUart class variable. In this sample,
 *  The murasaki::Uart class is instantiated. The Uart constructor receives the pointer to the UART_HandleTypeDef. Usually, the UART_HandleTypeDef variable is generated by
 *  CubeIDE. For example, "huart3" variable in the main.c file.
 *
 *  The platform.logger member variable hooks a murasaki::AbstractLogger variable. In this example, murasaki::UartLogger
 *  class variable is instantiated.
 *
 *  Finally, the debugger variable is initialized. The murasaki::Debugger constructor receives murasaki::AbstractLogger * type.
 * \code
 * void InitPlatform(UART_HandleTypeDef * uart_handle)
 * {
 *     murasaki::platform.uart_console = new murasaki::Uart(uart_handle);
 *     murasaki::platform.logger = new murasaki::UartLogger(murasaki::platform.uart_console);
 *
 *     murasak::debugger = new murasaki::Debugger(murasaki::platform.logger);
 * }
 *
 * \endcode
 */

/**
 * \defgroup MURASAKI_ABSTRACT_GROUP Abstract Classes
 * \ingroup MURASAKI_PLACEHOLDER
 * \brief Generic classes as template of the concrete class.
 * \details
 * Usually, application dodesn't instantiate these classes. But pointer may be declared
 * as abstract class as geneic placeholder.
 */

/**
 * \defgroup MURASAKI_SYNC_GROUP Synchronization and Exclusive access
 * \ingroup MURASAKI_PLACEHOLDER
 * \brief Sync between the task and interrupt. Make the resources thread safe.
 * \details
 * These classes are used as parts of the other classes.
 */

/**
 * @defgroup MURASAKI_HELPER_GROUP Helper classes
 * @ingroup MURASAKI_PLACEHOLDER
 * @brief Classes to support the murasaki-class.
 * @details
 * These classes are not used by customer.
 */

/**
 * @ingroup MURASAKI_PLACEHOLDER
 * @defgroup MURASAKI_FUNCTION_GROUP Utility functions
 * @brief Collection of the useful functions.
 */

#endif /* MURASAKI_4_MOD_HPP_ */

