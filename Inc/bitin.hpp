/**
 * @file bitin.hpp
 *
 * @date 2018/05/07
 * @author Seiichi "Suikan" Horie
 * @brief GPIO bit in class
 */

#ifndef BITIN_HPP_
#define BITIN_HPP_

#include <bitinstrategy.hpp>
#include "bitout.hpp"

#ifdef HAL_GPIO_MODULE_ENABLED
namespace murasaki {
/**
 * \ingroup MURASAKI_GROUP
 * @brief General purpose bit input.
 * \details
 * The BitIn class is the wrapper of the GPIO controller. To use the BitIn class,
 * make an instance with GPIO_TypeDef * type pointer. For example, to create
 * an instance for a switch peripheral:
 * \code
 *     my_swithc = new murasaki::BitIn(sw_port, sw_pin);
 * \endcode
 * Where sw_port and sw_pin are the macro generated by CubeIDE for GPIO pin.
 * the GPIO peripheral have to be configured to be right direction.
 */

class BitIn: public BitInStrategy {
public:
	/**
	 * @brief Constructor
	 * @param port Pinter to the port strict.
	 * @param pin Number of the pin to input.
	 */
	BitIn(GPIO_TypeDef * port, uint16_t pin);
	/**
	 * @brief Get a status of the output pin
	 * @return 1 or 0 as output state.
	 * @details
	 * The mean of "1" or "0" is system dependent.
	 *
	 * Usually, these represent "H" or "L" output state, respectively.
	 */
	virtual unsigned int Get(void);
	/**
	 * @brief pass the raw peripheral handler
	 * @return pointer to the GPIO_type variable hidden in a class.
	 */
	virtual void * GetPeripheralHandle();
private:
	const GPIO_type gpio_;
};

} /* namespace murasaki */

#endif // HAL_GPIO_ENABLED

#endif /* BITIN_HPP_ */
